import _extends from 'babel-runtime/helpers/extends';
import _objectWithoutProperties from 'babel-runtime/helpers/objectWithoutProperties';
import _classCallCheck from 'babel-runtime/helpers/classCallCheck';
import _createClass from 'babel-runtime/helpers/createClass';
import _possibleConstructorReturn from 'babel-runtime/helpers/possibleConstructorReturn';
import _inherits from 'babel-runtime/helpers/inherits';
import React, { createElement } from 'react';
import PropTypes from 'prop-types';
import EventListener from './EventDispatcher';
import ScrollElement from './ScrollElement';
import { toArrayChildren } from './util';

function noop() {}

var ScrollOverPack = function (_ScrollElement) {
  _inherits(ScrollOverPack, _ScrollElement);

  function ScrollOverPack(props) {
    _classCallCheck(this, ScrollOverPack);

    var _this = _possibleConstructorReturn(this, (ScrollOverPack.__proto__ || Object.getPrototypeOf(ScrollOverPack)).call(this, props));

    _this.scrollEventListener = function (e) {
      _this.getParam(e);
      var isTop = _this.elementShowHeight > _this.clientHeight + _this.leavePlayHeight;
      if (_this.enter || !_this.props.replay && isTop) {
        if (!_this.state.show) {
          _this.setState({
            show: true
          });
        }
        if (!_this.props.always && _this.eventType) {
          EventListener.removeEventListener(_this.eventType, _this.scrollEventListener, _this.target);
        }
      } else {
        var bottomLeave = _this.elementShowHeight < _this.playHeight;
        // 设置往上时的出场点...
        var topLeave = _this.props.replay ? isTop : null;
        if (topLeave || bottomLeave) {
          if (_this.state.show) {
            _this.setState({
              show: false
            });
          }
        }
      }
    };

    _this.children = toArrayChildren(props.children);
    _this.oneEnter = false;
    _this.enter = false;
    _this.state = {
      show: false,
      children: toArrayChildren(props.children)
    };
    return _this;
  }

  _createClass(ScrollOverPack, [{
    key: 'componentWillReceiveProps',
    value: function componentWillReceiveProps(nextProps) {
      var _this2 = this;

      this.setState({
        children: toArrayChildren(nextProps.children)
      }, function () {
        _this2.scrollEventListener();
      });
    }
  }, {
    key: 'render',
    value: function render() {
      var placeholderProps = _objectWithoutProperties(this.props, []);

      ['playScale', 'replay', 'component', 'always', 'scrollEvent', 'appear', 'location', 'targetId'].forEach(function (key) {
        return delete placeholderProps[key];
      });
      var childToRender = void 0;
      if (!this.oneEnter) {
        var show = !this.props.appear;
        var children = toArrayChildren(this.props.children).map(function (item) {
          return item.type.isTweenOne ? React.cloneElement(item, _extends({}, item.props, { paused: !show })) : React.cloneElement(item, item.props, show && item.props.children);
        });
        childToRender = createElement(this.props.component, _extends({}, placeholderProps), children);
        this.oneEnter = true;
      } else {
        if (!this.state.show) {
          this.children = this.children.map(function (item) {
            if (!item) {
              return null;
            }
            // 判断 TweenOne;
            if (item.type.isTweenOne) {
              return React.cloneElement(item, { reverse: true });
            }
            return React.cloneElement(item, {}, null);
          });
        } else {
          this.children = this.state.children;
        }
        childToRender = createElement(this.props.component, _extends({}, placeholderProps), this.children);
      }
      return childToRender;
    }
  }]);

  return ScrollOverPack;
}(ScrollElement);

ScrollOverPack.propTypes = {
  component: PropTypes.oneOfType([PropTypes.func, PropTypes.string]),
  playScale: PropTypes.any,
  always: PropTypes.bool,
  scrollEvent: PropTypes.func,
  children: PropTypes.any,
  className: PropTypes.string,
  style: PropTypes.any,
  replay: PropTypes.bool,
  onChange: PropTypes.func,
  appear: PropTypes.bool
};

ScrollOverPack.defaultProps = {
  component: 'div',
  playScale: 0.5,
  always: true,
  scrollEvent: noop,
  replay: false,
  onChange: noop,
  appear: true
};
ScrollOverPack.isScrollOverPack = true;

export default ScrollOverPack;